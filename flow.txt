導入：
1. Next.jsとは何なのか？
・Reactのフレームワーク。

2. なぜNext.jsが必要なのか？
・Reactにはないメリットがある。
・直感的なルーティングシステム(動的ルーティング、ルーティング用のライブラリが必要ない！RouteとかRouterとかね。)
・プリレンダリングでは静的生成(SSG)とサーバーサイドレンダリング(SSR)の両方をページ毎に決めることができる。

##########################################################

・コード分割
➡自動的にコード分割するから、必要なページだけを読み込むことになる。他のページは読み込まれないから、膨大なページでも対応可能。１つのページがエラー出しても、他ページは落ちない。

・プリフェッチング(外部データを事前に取得すること)
➡本番環境ではLINKタグで繋がっているページを先にバックグラウンド読み込んでおくことで、押したときに高速遷移することができる。

・プリレンダリング(SSG, SSR)
➡先にHTMLタグだけを用意しておくこと。JSは後で読み込ませることでページ表示速度があがる。SEO対策になる。Javascriptはそのページだけの最小限しか読み込まれていない状態。ページが完全にインタラクティブになる。このプロセスをハイドレーションと呼ぶ。これがNext.jsの特徴。Reactにはない。

・SSG(静的生成)
➡本番環境にアプリをビルドする時にHTMLを生成するプリレンダリング手法。基本的にはいつでもSSGがいい。ビルドするとCDNによって提供(キャッシュ)されるから(HTMLページが再利用される)、毎回のリクエストに対してHTMLをプリレンダリングするSSRを行うよりも高速だから。SEO対策になる。

例
・ブログ記事
・マーケティングページ
・ECサイトの商品リスト
・ヘルプやドキュメント

・SSR(サーバーサイドレンダリング)
➡毎回のリクエスト毎にHTMLを生成するプリレンダリング手法。開発モードは全てSSRで行われている。追加設定をしない限りcdnにキャッシュできないから遅くなる(TTFB(Time to first Byte):最初の１バイトが到着するまでの時間)けど、情報更新が多いページにはこっちを採用するべき。SEO対策が必要ない場合に使う。

例
・SNS
・頻繁に更新されるデータを表示するページ
・毎回のリクエストごとに内容が変わるページ
・ユーザーダッシュボードページ

・ページ毎にSSGかSSRかが選べる。

##########################################################

1. npm init next-app nextjs-blog
 1.1: pages/index.jsの文字の変更(ホットリローディング)

##########################################################

2. ページ間の移動
 2.1: Next.jsにおけるルーティングはファイル名に基づいて決定する。

 2.2: 新しいページを作成する(pages/posts/firstPage.js)

 2.3: Linkコンポーネント(クライアントサイドで遷移できる,
 ページ遷移がJavascriptを使っているからブラウザによって行われるページ遷移よりも高速。)

 2.4: htmlのbackgroundをyellowに変更して遷移させてみる。ページ全体をリロードしていないことが分かる。aタグなら全体をリフレッシュするから背景色がなくなってしまう。

##########################################################

3.アセット、メタデータ、CSS
➡Next.jsのスタイリングの方法
 3.1: 画像などの静的なアセット(トップレベルのpublicディレクトリ配下でサーブする)

 3.2: メタデータ(firstPostにHeadタグを追加する)

 3.3: レイアウトコンポーネント(components/layout.jsとlayout.module.cssを作成してchildrenとか作って読み込ませる。CSSモジュールを使えばReactコンポーネントの中でcssをインポートできるようになる。またコード分割の特徴がCSSモジュールに対しても機能する。各ページで読み込まれるCSSの量が減って、バンドルサイズを小さくできる)

 3.4: グローバルなスタイリング(pages/_app.jsを作成。これは全てのページに共通するコンポーネント。ページ間を移動するときに状態を保持するために利用できる。ここでしかグローバルcssはインポートできないようになっている。global.cssに記述する。)

 3.5: プロフィール画像を追加する(public/images/profile.jpgとして画像を保存する。layout.module.cssに追記する。styles/utils.module.cssとして複数のコンポーネントにまたがって使えるcssモジュールを準備。追記。layout.jsをhomeの有無によってガッツリ変更)

 3.6: トップページの更新(pages/index.js)

##########################################################

4.プリレンダリングとデータフェッチング
➡外部にあるブログデータを自分のアプリに読み込む方法を学ぶ.

★まずはSSGから
 4.1: Javascriptを無効にしてみる。JSなしでもレンダリングされていることが分かる。CSSは崩れるけど。ReactだとプリレンダリングされないからJS無効にするとページが表示されなくなる。

 4.2: 基本的にはSSG。最初の読み込みで外部データ(APIやらデータベース)無しの場合と有りの場合でも静的生成ができる。まずは有りの場合でやってみよう。getStaticPropsを使う。ビルド時に実行される。「このページにはいくつか外部に依存しているデータがあるよ。だからビルド時にこのページをプリレンダリングするときは、まずその依存関係をしっかり解決してよ！」

 4.3: マークダウンファイルにブログデータを記述する。grey-matterをnpmでインストールする。

 4.4: ファイルシステムからデータを取得するためのライブラリの作成(lib/posts.js)

 4.5: index.jsにてgetStaticPropsを作成。

 4.6: index.jsにてsectionを追加してブログデータを表示。

 4.7: 外部APIやデータベースでもSSGが可能

 4.8: 開発環境ではgetStaticPropsは毎回のリクエストごとに実行されるが、本番環境ではビルド時にのみ実行される

 4.9: リクエスト時に毎回データを取得する必要がある場合は？➡SSGではなくSSRを使う。またはプリレンダリングをスキップする。

★SSRでrequest毎にデータを返すとき
 4.10: getServerSidePropsを使う。今回の例では必要ないので実装はしない。

★クライアントサイドレンダリング
➡データをプリレンダリングする必要がない場合に使う。クライアントサイドでデータ取得する。
・外部データを必要としない部分だけプリレンダリングさせる。SSG。
・だけどデータが頻繁に更新される部分もある。そこはクライアントサイドでデータ取得してもらう的な。このケースではSWRと呼ばれるReactフックを活用する方がいい。
例：
ユーザーダッシュボード

##########################################################

5. 動的ルーティング　
➡外部データに含まれたID等を使ってURLのルーティングとして利用する。

 5.1: pages/posts/[id].jsを作成する。

 5.2: lib/post.jsの中身に関数を追記する。各オブジェクトには params キーが存在して、id キーを持ったオブジェクトを含んでいなくてはなりません（ファイル名で [id] を使用するため）。そうしなければ、getStaticPaths は失敗します。

 5.3: getStaticPropsを実装する.id(ファイル名)に基づいてブログデータを取得するためにlib/posts.jsに関数を追記。さらにpages/posts/[id].jsにSSGを実装する。

 5.4: マークダウンをレンダーする。npm i remark remark-html。getPostDataに追記する。そしてHTMLに表示。

 5.5: 投稿ページを磨き上げる。Headタグの追加。(option)日付フォーマット修正。npm i date-fns。components/data.jsにDateコンポーネント作成。articlesタグを[id].jsに追記。

 5.6: インデックスページを磨き上げる。index.jsのトップページでLINKタグを貼る。

 5.7: フォールバックについて。trueは巨大なECサイトとかに使われるらしい。blockingは知りません。

 5.8: 404ページの作成。pages/404.jsを作成。ビルド時に静的に生成される。

6. APIルート
➡APIエンドポイントをNode.js関数として簡単に作成可能。　
 6.1: pages/apiの中にNode.js関数を定義する.
 /api/helloにアクセスして確認する。
 6.2: フォーム入力の処理のときにAPIルートを使うと良い。

7. デプロイ
➡Next.jsはVercel社が作ったからかなりデプロイしやすい。ＤＰＳワークフロー(Develop, Preview, Ship)
